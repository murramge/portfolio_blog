---
title: '브라우저는 과연 어떻게 화면을 렌더링 하는가? '
date: '2024-04-04'
lastmod: '2024-04-04'
tags: ['frontend', 'browser', 'rendering', 'criticalRenderingPath', 'DOM']
draft: false
summary: '프론트엔드 개발자라면 기본적으로 알아야하는 브라우저 렌더링 원리에 대해서 정리한 글입니다. '
---

## 브라우저는 어떻게 화면을 <span style={{background:'#8F98DC',color:'#fff'}}>렌더링</span> 하는가?

    ### Html 파싱 -> DOM 트리 생성
    <p style={{padding:10, fontWeight:700, }}> 바이트 -> 문자 -> 토큰 -> 노드 -> DOM</p>


    브라우저의 어떤 사이트 주소를 입력하게되면, 그 주소에 있는 서버가 약속되어있는 html 파일을 우리 브라우저로 전송을 하게 된다. 
    
    이 때 전송 받는 html의 파일은 8비트의 데이터 형태로 전송되게 된다.
    이를 전문용어로 바이트 스트림 이라고 한다. 
    
    그래서 우리 브라우저는, 전송받은 이 바이트 브라우저를 -> 문자 형태로 변환하게 된다. 그리고, 가지고 있는 토큰과 비교를 해서 해당 문자가 html 코드인지 확인을 한다.
    여기서 이 토큰이라는 것은 브라우저에 저장되어 있는 html의 시작 혹은 종료 태그 그리고 속성과 속성 값 등 약속된 여러가지 값들을 의미하게 된다.

    즉, 토큰은 바이트코드에서 문자로 해석된 이 해당 문자가 html 코드인지 확인하는 일종의 설명서라고 보면 된다. 
    그리고 이러한 토큰을 통해서 이 문자가 html 코드인지 아닌지 확인하는 과정을 "토큰화"[^1] 라고 한다.

    이 토큰화 과정을 통해 노드가 생성이 된다.
    노드라는 것은 DOM 트리를 이루는 거대한 구조의 한 단위이다. Ex> head, meta, link, title 등 이러한 것들이 노드 라는 뜻! 이런것들이 모이고 모여서 DOM 트리를 이루는 거대한 구조가 된다.
    쉽게 말해서 DOM은 마크업과 1:1 관계를 맺는다는 뜻이다.

    ### DOM 트리에 관해서

![스크린샷 2024-04-04 22 20 41](https://github.com/murramge/codingtest/assets/60298173/0cebbd31-c4d9-4ac8-9c30-4bc2113c0d7e)

    일단 DOM은 document object model 이라는 뜻으로 문서 객체 모델이다. Document는 트리의 최상위에 있는 document의 객체들(노드)이 있는 것이다. 이것이 tree 구조로 되어있으니, DOM tree라고 한다.

    html 구조를 짰다면, 이러한 Html 노드 안에, 또 Head가 있고, meta,link,title 이라는 하위 노드가 있고.. 이런 형식으로 하나하나 노드로 이루어져 있다.
    이것과 똑같이 DOM 트리도, Document 아래에 html 안에 head, body 이렇게 트리구조로 되어있다. 브라우저가 해석하기 편한 방식으로 앞서 이야기한 토큰화를 통해서 변환된 객체 트리이다.

    그리고 DOM 트리에서 link나 image들은 무언가를 다운로드 해주어야 하는 노드들이다. 브라우저가 DOM 트리를 생성할 때 링크와 이미지같은 태그를 만나게 되면, 해당 태그 안에 명시되어 있는 리소스를 다운로드 한다.
    그리고 DOM 트리 안의 script[^2] 노드는 브라우저는 DOM 생성을 중단하고 script 노드 안에 들어있는 자바스크립트 코드를 해석하게 된다.
    
     ### CSS 파싱 -> CSSOM 트리 생성

       <p style={{padding:10, fontWeight:700, }}> 바이트 -> 문자 -> 토큰 -> 노드 -> CSSOM</p>


     사실 CSS도 html과 똑같은 방식으로 생성된다. 이것 또한 브라우저로 전달받은 CSS 파일을 문자로 해석하고, 토큰화 한 후 노드를 만들고 거대한 CSSOM 트리를 생성한다.

    ### 렌더트리

![스크린샷 2024-04-04 22 57 09](https://github.com/murramge/codingtest/assets/60298173/d31a478d-0113-4077-aab5-1b5bbcff5f81)



    - 리플로우 (레이아웃 단계)

    그렇게 생성된 DOM 트리와 CSSOM 트리를 합쳐서 랜더트리 라는 것을 생성하게 된다.

    이를 크게 레이아웃 단계(리플로우) 라고 표현한다. 앞서 만들어진 DOM과 계산된 스타일을 따라가면서 요소의 크기나 죄표와 같은 정보를 담은 레이아웃 트리를 생성하게 된다.
    DOM 정보와 함꼐, CSS에 들어있던 스타일 정보를 합친다.

    이때, 중요한 것은 css의 display none과 같은 속성은 이 렌더트리 안에 해당 요소가 포함되지 않는다는 점이다.
    이렇게 되면, 웹 접근성을 위해 텍스트를 숨겨야 해서 display none 과 같은 속성을 적용해버리면, 화면을 읽어주는 스크린리더같은 프로그램들이 none 속성이 적용된 요소를 인식하지 않는 문제가 발생하게 된다.
    때문에 접근성을 위해서 요소를 숨겨줄 때는 display none과 같은 설정을 써서는 안 된다.[^3]

    - 페인트 (리페인트)

    앞서 만들어진 렌더트리를 따라서, 페인트 기록이 생성된다. 
    
    이 페인트 기록에는 요소를 렌더링하는 순서, 
    지금까지의 정보를 바탕으로 한 페이지를 여러개의 레이어로 나눈 다음 
    그 위에 텍스트, 색, 이미지, border, 그림자 등 모든 시각적인 부분을 그리는 작업이 진행되게 된다.



![스크린샷 2024-04-04 23 10 24](https://github.com/murramge/codingtest/assets/60298173/80a7231e-bf71-4701-8f82-86b931ef6c09)

   👉 내가 CSS를 수정해서, 화면에 보여지는 레이아웃이 변경된다고 했을 때, 즉 left, top같은 css 속성을 이용해서 레이아웃이 변경되게 된다면
   브라우저는 이 "렌더트리"를 다시 생성하게 되고, 그리고 레이아웃 단계의 페인트 단계도 이어서 다시 실행하게 된다. 그리고 컴포지트하고 사용자에게 보여주게된다.

   때문에, 브라우저에게 있어서 이 레이아웃을 중간에 변경하는 것은 상당히 부담이 되는 작업이다. 이러한 현상을 바로 리플로우 현상이라고 한다.

   👉 리플로우와 리페인트가 반드시 순차적으로 동시에 실행되지는 않는다. 레이아웃의 영향이 없는 변경 (그냥 컬러만 바꾼다던가..) 은 리플로우 없이 리페인트만 진행한다.

    👉 css 속성 중에 transform과 opacity는 리플로우, 리페인트를 생략한다 (GPU가 관여할 수 있는 속성)
    우리가 앞서 생성한 DOM 트리를 변경하지 않도록 설계가 되어있다. 

    그렇기 때문에 좋은 애니메이션 속성을 이용하려면, transform 속성을 이용하는 것이 좋다!


    ## 컴포지팅 단계

    앞서 페인팅 단계에서 만들어준 여러가지 레이어를 스크린에 픽셀로 표현하게 되고, 나누어져 있던 레이어들을 하나로 합성해서 페이지를 완성하게 된다.




[^1]: 토큰화 : 자료 -> < 태그열림상태 -> a-z 태그 이름 상태 (시작태그 토큰 생성) -> / 태그 이름상태 (종료태그 토큰 생성) -> > 자료상태 (토큰이 생성됨) 이와같은 사이클이 반복된다.
[^2]: js인 script 태그를 만나면, 스크립트가 해석 및 실행되는 동안 문서의 파싱은 중단되게 된다. 스크립트가 외부에 있는 경우 네트워크로부터 자원을 가져와야 하는데, 이 또한 실시간 처리되고 자원을 받을 때까지 파싱은 중단된다. 한 편 스타일시트는 DOM 트리를 변경하지 않기 때문에 문서파싱을 기다리거나 중단하지 않는다. 스크립트가 문서를 파싱하는 동안 스타일정보를 요청하는 경우, 문제가 된다. 이 경우에, 스크립트가 문서를 파싱하는 동안 브라우저는 다른 작업을 수행하지 않기 때문에 스타일이 파싱되지 않은 상태가 되고 화면 레이아웃이 제대로 구성되지 않은 상태에서 사용자에게 뷰를 제공하게 될 확률 이 높다. 이러한 문제 때문에 우리는 보통 Script 소스를 body 태그 끝에 두는 것을 권장하고 있다. [자료참고](https://webclub.tistory.com/630)  
[^3]: [웹 접근성을 고려하여 텍스트 숨기기](https://velog.io/@ursr0706/%EC%9B%B9-%EC%A0%91%EA%B7%BC%EC%84%B1%EC%9D%84-%EA%B3%A0%EB%A0%A4%ED%95%98%EC%97%AC-%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%88%A8%EA%B8%B0%EA%B8%B0) clip-path를 이용하여 숨기기

